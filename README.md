Jose Cuellar 8907826 Nicholas Duncan 3937679

For this file we have a simple main that continuously loops and loops for new input. It parses the input based on the inclusion of special tokens (<, >, |, &) and the commands. We used stringstream to make this happen. Then the interpretter class interprets the commands by splitting up the command tokens into dynamically allocated arrays that hold each command (e.g. ls -l) is a single command but each is put as a separate part of the array. We then fork and if there is a pipe then we fork again to pass the next command. We also make sure to handle the other special characters in that command. A pipe is created from the stderr of the child to the parent so that the parent can print all commands in the format of "ERROR: ". Execvp is called with the aforementioned command array and then the signal handler for sigchld will print out the error message once the child has terminated. If & is present in the command string (as the last character) then the shell does not wait and continues until our signal handler catches it. Execution continues until an eof is input through Ctrl + D. Ctrl + C has been handled to do nothing.

The biggest problem that we encountered when doing this project was handling errors that occurred within execvp when execvp terminated normally, but the program, such as cat, did not terminate normally and printed its own error message. We had to use a pipe to send the stderr to the parent to print in the proper format. This required several iterations and a lot of bug testing to perfect!
